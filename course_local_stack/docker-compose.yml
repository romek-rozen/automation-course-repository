# =============================================================================
# DOCKER COMPOSE - WERSJA LOKALNA (do nauki i testow)
# =============================================================================
# Wersja lokalna stacka:
# - Bez Caddy (reverse proxy) - dostep przez localhost:port
# - Z trybem kolejkowym (n8n + worker + webhook)
#
# Stack zawiera:
# - n8n (workflow automation) + worker + webhook
# - NocoDB (no-code database)
# - PostgreSQL (glowna baza danych)
# - Redis (cache + kolejki)
# - MinIO (S3-compatible storage)
# - Qdrant (vector database)
#
# Uruchomienie: docker compose up -d
# Zatrzymanie:  docker compose down
# =============================================================================

services:
  # === N8N STACK ===
  # Wspolna konfiguracja dla wszystkich instancji n8n
  x-n8n-shared: &n8n-shared
    image: docker.n8n.io/n8nio/n8n
    restart: unless-stopped
    env_file: .env
    depends_on:
      pg_database:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      - N8N_HOST=localhost
      - N8N_PORT=5678
      - N8N_PROTOCOL=http
      - NODE_ENV=development
      - NODE_OPTIONS=--max-old-space-size=2048
      - NODE_FUNCTION_ALLOW_EXTERNAL=cheerio,imap,util,quoted-printable,mailparser
      - WEBHOOK_URL=http://localhost:5678/
      - GENERIC_TIMEZONE=${N8N_GENERIC_TIMEZONE}
      # Baza danych
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=pg_database
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_N8N_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_N8N_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_N8N_PASSWORD}
      # Kolejki Redis
      - EXECUTIONS_MODE=queue
      - QUEUE_BULL_REDIS_HOST=${QUEUE_BULL_REDIS_HOST}
      - QUEUE_BULL_REDIS_PORT=${QUEUE_BULL_REDIS_PORT}
      - QUEUE_BULL_REDIS_PASSWORD=${QUEUE_BULL_REDIS_PASSWORD}
      - QUEUE_BULL_REDIS_DB=${QUEUE_BULL_REDIS_DB}
      - QUEUE_HEALTH_CHECK_ACTIVE=true
      # Bezpieczenstwo
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      # Czyszczenie danych
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - EXECUTIONS_DATA_PRUNE_MAX_COUNT=10000
      # Wydajnosc
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_CONCURRENCY_PRODUCTION_LIMIT=10
      - N8N_DEFAULT_BINARY_DATA_MODE=filesystem
      # Community packages
      - N8N_COMMUNITY_PACKAGES_ALLOW_TOOL_USAGE=true
      - N8N_NODE_MODULES_TO_ALLOW=cheerio
    volumes:
      - ./volumes/n8n/data:/home/node/.n8n
      - ./volumes/n8n/local_files:/files
    networks:
      - local

  # Glowna instancja n8n (UI + API)
  n8n:
    <<: *n8n-shared
    ports:
      - "5678:5678"

  # Worker - przetwarza zadania z kolejki
  n8n-worker:
    <<: *n8n-shared
    command: worker
    depends_on:
      - n8n

  # Webhook processor - odbiera webhooki
  n8n-webhook:
    <<: *n8n-shared
    command: webhook
    depends_on:
      - n8n

  # === NOCODB ===
  nocodb:
    image: nocodb/nocodb:latest
    env_file: .env
    depends_on:
      pg_database:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
    restart: unless-stopped
    volumes:
      - ./volumes/nocodb:/usr/app/data
    ports:
      - "8080:8080"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - local
    environment:
      - NC_DB=pg://pg_database:5432?d=${POSTGRES_NOCODB_DB}&u=${POSTGRES_NOCODB_USER}&p=${POSTGRES_NOCODB_PASSWORD}
      - NC_AUTH_JWT_SECRET=${NC_JWT_SECRET}
      - NC_INVITE_ONLY_SIGNUP=true
      - NC_DISABLE_TELE=true
      - DB_QUERY_LIMIT_DEFAULT=25
      - DB_QUERY_LIMIT_GROUP_BY_GROUP=10
      - DB_QUERY_LIMIT_GROUP_BY_RECORD=10
      - DB_QUERY_LIMIT_MAX=100
      - NC_ALLOW_LOCAL_HOOKS=true
      - PORT=8080
      - NC_REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/15

  # === POSTGRESQL ===
  pg_database:
    image: postgres:16
    env_file: .env
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: postgres
      # Zmienne dla init-data.sh (tworzenie baz i userow dla aplikacji)
      POSTGRES_NOCODB_DB: ${POSTGRES_NOCODB_DB}
      POSTGRES_NOCODB_USER: ${POSTGRES_NOCODB_USER}
      POSTGRES_NOCODB_PASSWORD: ${POSTGRES_NOCODB_PASSWORD}
      POSTGRES_N8N_DB: ${POSTGRES_N8N_DB}
      POSTGRES_N8N_USER: ${POSTGRES_N8N_USER}
      POSTGRES_N8N_PASSWORD: ${POSTGRES_N8N_PASSWORD}
    volumes:
      - ./volumes/db_data:/var/lib/postgresql/data
      - ./init-data.sh:/docker-entrypoint-initdb.d/init-data.sh
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    ports:
      - "5432:5432"
    networks:
      - local

  # === REDIS ===
  redis:
    image: redis:8-alpine
    env_file: .env
    command: redis-server --requirepass "${REDIS_PASSWORD}"
    restart: unless-stopped
    volumes:
      - ./volumes/redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    ports:
      - "6379:6379"
    networks:
      - local

  # === MINIO (S3 Storage) ===
  minio:
    image: minio/minio:latest
    restart: unless-stopped
    env_file: .env
    entrypoint: /bin/sh
    command: -c 'mkdir -p /data/nocodb && minio server /data --console-address ":9001"'
    volumes:
      - ./volumes/minio_data:/data
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    ports:
      - "9000:9000"
      - "9001:9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - local

  # === QDRANT (Vector Database) ===
  qdrant:
    image: qdrant/qdrant:latest
    restart: unless-stopped
    env_file: .env
    environment:
      - QDRANT__LOG_LEVEL=INFO
      - QDRANT__STORAGE__ON_DISK_PAYLOAD=true
    volumes:
      - ./volumes/qdrant_storage:/qdrant/storage
    ports:
      - "6333:6333"
      - "6334:6334"
    healthcheck:
      test: ["CMD-SHELL", "timeout 5 bash -c ':> /dev/tcp/localhost/6333' || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - local

networks:
  local:
    driver: bridge
